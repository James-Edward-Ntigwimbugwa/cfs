import datetime
import os
import secrets
import string
import tempfile
import uuid
from base64 import b64decode, b64encode
from pathlib import Path

import pyAesCrypt
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist

from {{package_name}}_dto.enums import FileVisibiltyChoices
from {{package_name}}_files.models import FileKeys


class UploadFile:
    # Buffer size for pyAesCrypt (in bytes)
    BUFFER_SIZE = 64 * 1024  # 64KB

    @classmethod
    def _generate_secure_password(cls, length: int = 32) -> str:
        """Generate a cryptographically secure random password."""
        alphabet = string.ascii_letters + string.digits + '!@#$%^&*'
        return ''.join(secrets.choice(alphabet) for _ in range(length))

    @classmethod
    def base64_handler(cls, base64_string, file_extension, parent_folder, visibility):
        try:
            byt_cont = b64decode(base64_string, validate=True)
        except Exception as e:
            return False, f'Invalid base64: {e}', None, None

        # Build folder path
        date_str = datetime.datetime.now().strftime('%Y-%m-%d')
        new_folder = f'{parent_folder}/{date_str}'
        full_dir = Path(settings.MEDIA_ROOT) / new_folder

        full_dir.mkdir(parents=True, exist_ok=True)

        # Generate unique identifiers
        file_id = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
        unique_suffix = str(uuid.uuid4())
        plain_filename = f'{file_id}-{unique_suffix}{file_extension}'
        absolute_file_path = full_dir / plain_filename

        # Write original file
        with open(absolute_file_path, 'wb') as f:
            f.write(byt_cont)

        # Public files: return immediately
        if visibility == FileVisibiltyChoices.PUBLIC.value:
            relative_path = f'/{new_folder}/{plain_filename}'
            return True, '', file_id, relative_path

        # Private: encrypt
        encrypted_filename = f'{file_id}-enc-{unique_suffix}{file_extension}.aes'
        output_file_path = full_dir / encrypted_filename
        relative_file_path = f'/{new_folder}/{encrypted_filename}'

        # Encrypt and clean up
        success, key_or_error = cls.encrypt_file(file_path=str(absolute_file_path), output_file_path=str(output_file_path))

        if not success:
            # Clean up on failure
            if absolute_file_path.exists():
                absolute_file_path.unlink()
            if output_file_path.exists():
                output_file_path.unlink()
            return False, key_or_error, None, None

        return True, key_or_error, file_id, relative_file_path

    @classmethod
    def encrypt_file(cls, file_path: str, output_file_path: str):
        """Encrypt file using pyAesCrypt with a randomly generated password."""
        try:
            password = cls._generate_secure_password()
            pyAesCrypt.encryptFile(file_path, output_file_path, password, cls.BUFFER_SIZE)
            # Remove original file
            os.remove(file_path)
            return True, password
        except Exception as e:
            return False, str(e)

    @classmethod
    def decrypt_file(cls, file_path: str, password: str):
        """Decrypt .aes file to a new file (without 'enc' and .aes)."""
        abs_input = Path(settings.MEDIA_ROOT) / file_path.lstrip('/')
        if not abs_input.exists():
            raise FileNotFoundError(f'Encrypted file not found: {abs_input}')

        # Derive output path: remove 'enc' and '.aes'
        output_name = abs_input.name.replace('-enc-', '-dec-').replace('.aes', '')
        output_path = abs_input.parent / output_name

        try:
            pyAesCrypt.decryptFile(str(abs_input), str(output_path), password, cls.BUFFER_SIZE)
            return True, str(output_path)
        except Exception as e:
            if output_path.exists():
                output_path.unlink()
            raise ValueError(f'Decryption failed: {e}')

    @classmethod
    def base64_decrypted_file(cls, file_path: str):
        """
        Decrypts an encrypted file (if applicable) by looking up its key in FileKeys,
        and returns the original file content as a Base64 string.

        Args:
            file_path (str): Relative path like '/documents/2025-10-08/20251008202520-enc-uuid.pdf.aes'

        Returns:
            str: Base64-encoded original file content.

        Raises:
            FileNotFoundError: If file or key not found.
            ValueError: If file is not encrypted or decryption fails.
        """
        abs_file_path = Path(settings.MEDIA_ROOT) / file_path.lstrip('/')

        # Step 1: Check if file exists
        if not abs_file_path.is_file():
            raise FileNotFoundError(f'File not found on disk: {abs_file_path}')

        # Step 2: Check if it's an encrypted file (.aes + '-enc-' in name)
        filename = abs_file_path.name
        if not (filename.endswith('.aes') and '-enc-' in filename):
            # It's a public/unencrypted file â€” return as-is
            with open(abs_file_path, 'rb') as f:
                return b64encode(f.read()).decode('utf-8')

        # Step 3: Extract file_id (the part before '-enc-')
        try:
            file_id = filename.split('-enc-')[0]
            if not file_id.isdigit() or len(file_id) != 14:
                raise ValueError('Invalid file_id format in encrypted filename.')
        except Exception as e:
            raise ValueError(f'Failed to parse file_id from filename: {e}')

        # Step 4: Look up encryption key (password) in FileKeys
        try:
            file_key_record = FileKeys.objects.get(key_file_id=file_id, key_is_active=True)
            password = file_key_record.key_name
        except ObjectDoesNotExist:
            raise FileNotFoundError(f'No active encryption key found for file_id: {file_id}')

        if not password:
            raise ValueError(f'Encryption key is empty for file_id: {file_id}')

        # Step 5: Decrypt to temp file
        original_name = filename.replace('-enc-', '-dec-').replace('.aes', '')
        with tempfile.NamedTemporaryFile(dir=abs_file_path.parent, prefix='tmp_', suffix=original_name, delete=False) as tmp_file:
            temp_decrypted_path = Path(tmp_file.name)

        try:
            # Perform decryption
            pyAesCrypt.decryptFile(str(abs_file_path), str(temp_decrypted_path), password, cls.BUFFER_SIZE)

            # Read and encode
            with open(temp_decrypted_path, 'rb') as f:
                content = f.read()
            return b64encode(content).decode('utf-8')

        except Exception as e:
            raise ValueError(f'Decryption failed (corrupted file or wrong key): {e}')

        finally:
            # Clean up temporary decrypted file
            if temp_decrypted_path.exists():
                try:
                    os.remove(temp_decrypted_path)
                except OSError:
                    pass  # Ignore cleanup errors

    @classmethod
    def aspect_ratio_calculator(cls, width, height):
        try:
            ratio = round(int(width) / int(height), 2)
            return ratio
        except (ValueError, ZeroDivisionError):
            return 0.0
