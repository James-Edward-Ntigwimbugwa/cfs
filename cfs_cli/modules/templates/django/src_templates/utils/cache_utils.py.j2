import logging
from dotenv import dotenv_values
from django.core.cache import cache
from {{package_name}}_utils.utils import Utils
import redis

config = dotenv_values('.env')
CACHE_TIMEOUT = int(config.get("CACHE_TIMEOUT", 3600))
logger = logging.getLogger(__name__)

def get_redis_client() -> redis.Redis:
    return redis.from_url(config["REDIS_URL"])

def get_cached_model_or_db(model_class, identifier):
    """
    Retrieve a model instance from cache or DB using any 'unique_id'-like field or PK.
    """
    field_name, key_value = _detect_identifier_field(model_class, identifier)
    if not field_name or not key_value:
        return None

    key = f"{model_class._meta.label_lower}:{field_name}:{key_value}"
    instance = cache.get(key)

    if instance:
        return instance

    try:
        instance = model_class.objects.filter(**{field_name: key_value}).first()
        print(field_name, key_value)
        if instance:
            cache.set(key, instance, timeout=CACHE_TIMEOUT)
        return instance
    except Exception as e:
        logger.error(f"DB ERROR for {model_class.__name__}.{field_name}={key_value} → {e}")
        return None


def delete_cached_model_or_db(model_class, identifier):
    """
    Delete the cache key for a model instance and optionally refresh it.
    """
    field_name, key_value = _detect_identifier_field(model_class, identifier)
    if not field_name or not key_value:
        return None

    key = f"{model_class._meta.label_lower}:{field_name}:{key_value}"
    cache.delete(key)


    try:
        instance = model_class.objects.filter(**{field_name: key_value}).first()
        if instance:
            cache.set(key, instance, timeout=CACHE_TIMEOUT)
        return instance
    except Exception as e:
        logger.error(f"DELETE ERROR for {model_class.__name__}.{field_name}={key_value} → {e}")
        return None


def _detect_identifier_field(model_class, identifier):
    """
    Tries to resolve a unique field name and value from an identifier.
    Returns (field_name, value)
    """
    try:
        # TODO: ....unique_id is comming in a format at is not identified by the function so it falls back to pk, change format
        
        # if Utils.is_valid_uuid(identifier):
        for field in model_class._meta.fields:
            if "unique_id" in field.name:
                return field.name, identifier
        # else:
        return "pk", identifier  # fallback to primary key
    except Exception as e:
        logger.error(f"Identifier detection error in {model_class.__name__} → {e}")
    return None, None


